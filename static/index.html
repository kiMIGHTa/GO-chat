<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Realtime Chatroom</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <!-- Display Name Modal -->
    <div id="displayNameModal" class="modal">
      <div class="modal-content">
        <h2>Welcome to the Chatroom</h2>
        <p>Please enter your display name to join the conversation:</p>
        <form id="displayNameForm">
          <input
            type="text"
            id="displayNameInput"
            placeholder="Enter your display name..."
            maxlength="50"
            required
          />
          <div id="displayNameError" class="error-message"></div>
          <button type="submit" id="joinButton">Join Chat</button>
        </form>
      </div>
    </div>

    <!-- Main Chat Interface -->
    <div id="chatContainer" class="chat-container">
      <!-- Header -->
      <div class="header">
        <h1>Realtime Chatroom</h1>
        <div class="chat-header-info" id="chatHeaderInfo">
          <span id="activeConversationName">Public Chatroom</span>
        </div>
        <div class="connection-status">
          <div id="statusIndicator" class="status-indicator connecting"></div>
          <span id="statusText">Connecting...</span>
        </div>
      </div>

      <!-- Error Display Area -->
      <div id="errorDisplay" class="error-display"></div>

      <!-- Main Content -->
      <div class="main-content">
        <!-- Chat Section -->
        <div class="chat-section">
          <!-- Messages Container -->
          <div id="messagesContainer" class="messages-container">
            <!-- Messages will be dynamically added here -->
          </div>

          <!-- Message Input Section -->
          <div class="input-section">
            <form id="messageForm" class="input-form">
              <input
                type="text"
                id="messageInput"
                class="message-input"
                placeholder="Type your message..."
                maxlength="1000"
                disabled
              />
              <button
                type="submit"
                id="sendButton"
                class="send-button"
                disabled
              >
                Send
              </button>
            </form>
          </div>
        </div>

        <!-- Users Sidebar -->
        <div class="users-sidebar">
          <div class="users-header">
            <h3>Online Users</h3>
            <div id="usersCount" class="users-count">0 users online</div>
          </div>
          <div id="usersList" class="users-list">
            <!-- Public chatroom button -->
            <div class="user-item public-chat active" id="publicChatButton">
              <span class="user-name">üì¢ Public Chatroom</span>
            </div>
            <!-- Online users will be dynamically added here -->
          </div>
        </div>
      </div>
    </div>

    <script>
      // ConversationManager class for managing private and public conversations
      class ConversationManager {
        constructor() {
          // Map to store conversations: null key for public, username for private
          this.conversations = new Map();
          // Initialize public conversation with empty array
          this.conversations.set(null, []);
          // Track active conversation: null for public, string for private
          this.activeConversation = null;
          // Map to track unread message counts per user
          this.unreadCounts = new Map();
          // Map to store scroll positions per conversation
          this.scrollPositions = new Map();
          // Maximum messages per conversation to prevent memory issues
          this.maxMessagesPerConversation = 100;
        }

        // Switch to a conversation (null for public, username for private)
        switchConversation(username) {
          // Save scroll position of current conversation before switching
          if (this.activeConversation !== null || username !== this.activeConversation) {
            this.saveScrollPosition(this.activeConversation);
          }
          
          this.activeConversation = username;
          // Mark conversation as read when switching to it
          this.markAsRead(username);
        }

        // Add message to appropriate conversation
        addMessage(message) {
          // Determine which conversation this message belongs to
          let conversationKey = null;

          if (message.type === "private") {
            // For private messages, determine the other user
            // If we sent it, the conversation is with the recipient (To)
            // If we received it, the conversation is with the sender (From)
            const currentUser = displayName;
            conversationKey =
              message.from === currentUser ? message.to : message.from;
          } else {
            // Public messages go to null key
            conversationKey = null;
          }

          // Initialize conversation if it doesn't exist
          if (!this.conversations.has(conversationKey)) {
            this.conversations.set(conversationKey, []);
          }

          // Get conversation messages
          const messages = this.conversations.get(conversationKey);
          
          // Add message to conversation
          messages.push(message);

          // Limit conversation history to prevent memory issues
          if (messages.length > this.maxMessagesPerConversation) {
            // Remove oldest messages, keeping only the last maxMessagesPerConversation
            messages.splice(0, messages.length - this.maxMessagesPerConversation);
          }

          // Update unread count if message is not for active conversation
          if (conversationKey !== this.activeConversation) {
            this.incrementUnreadCount(conversationKey);
          }
        }

        // Get messages for a conversation
        getMessages(username) {
          return this.conversations.get(username) || [];
        }

        // Mark conversation as read
        markAsRead(username) {
          this.unreadCounts.set(username, 0);
        }

        // Get unread count for a user
        getUnreadCount(username) {
          return this.unreadCounts.get(username) || 0;
        }

        // Increment unread count for a conversation
        incrementUnreadCount(username) {
          const currentCount = this.getUnreadCount(username);
          this.unreadCounts.set(username, currentCount + 1);
        }

        // Save scroll position for a conversation
        saveScrollPosition(username) {
          if (messagesContainer) {
            this.scrollPositions.set(username, messagesContainer.scrollTop);
          }
        }

        // Get saved scroll position for a conversation
        getScrollPosition(username) {
          return this.scrollPositions.get(username) || null;
        }

        // Clear conversation when user disconnects
        clearConversation(username) {
          this.conversations.delete(username);
          this.unreadCounts.delete(username);
          this.scrollPositions.delete(username);
        }
      }

      // Global variables
      let ws = null;
      let displayName = "";
      let isConnected = false;
      let reconnectAttempts = 0;
      const maxReconnectAttempts = 10;
      let reconnectTimeout = null;
      let connectionAttempts = 0;
      let lastConnectionTime = null;
      let conversationManager = null; // Will be initialized after displayName is set

      // DOM elements
      const displayNameModal = document.getElementById("displayNameModal");
      const chatContainer = document.getElementById("chatContainer");
      const displayNameForm = document.getElementById("displayNameForm");
      const displayNameInput = document.getElementById("displayNameInput");
      const displayNameError = document.getElementById("displayNameError");
      const joinButton = document.getElementById("joinButton");
      const messagesContainer = document.getElementById("messagesContainer");
      const messageForm = document.getElementById("messageForm");
      const messageInput = document.getElementById("messageInput");
      const sendButton = document.getElementById("sendButton");
      const usersList = document.getElementById("usersList");
      const usersCount = document.getElementById("usersCount");
      const statusIndicator = document.getElementById("statusIndicator");
      const statusText = document.getElementById("statusText");
      const errorDisplay = document.getElementById("errorDisplay");
      const activeConversationName = document.getElementById("activeConversationName");

      // Initialize the application
      document.addEventListener("DOMContentLoaded", function () {
        setupEventListeners();
        startConnectionHealthCheck();
        displayNameInput.focus();
      });

      // Setup event listeners
      function setupEventListeners() {
        // Display name form submission
        displayNameForm.addEventListener("submit", handleDisplayNameSubmit);

        // Real-time display name validation
        displayNameInput.addEventListener("input", validateDisplayName);

        // Message form submission
        messageForm.addEventListener("submit", handleMessageSubmit);

        // Enter key support for message input
        messageInput.addEventListener("keypress", function (e) {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            handleMessageSubmit(e);
          }
        });

        // Real-time message validation
        messageInput.addEventListener("input", validateMessage);

        // Public chatroom button click handler
        const publicChatButton = document.getElementById("publicChatButton");
        if (publicChatButton) {
          publicChatButton.addEventListener("click", function () {
            handlePublicChatClick();
          });
        }
      }

      // Handle public chatroom button click
      function handlePublicChatClick() {
        if (!conversationManager) return;

        // Switch to public conversation
        conversationManager.switchConversation(null);

        // Update UI to show public conversation
        updateActiveConversation(null);

        // Update chat header to show public chatroom
        updateChatHeader(null);

        // Update message input placeholder
        updateMessagePlaceholder(null);

        // Clear unread badge for public chat (if any)
        updateUnreadBadge(null, 0);

        // Load public conversation history
        loadConversationHistory(null);
      }

      // Handle display name form submission
      function handleDisplayNameSubmit(e) {
        e.preventDefault();

        const name = displayNameInput.value.trim();
        if (!validateDisplayNameInput(name)) {
          return;
        }

        displayName = name;
        joinButton.disabled = true;
        joinButton.textContent = "Joining...";

        // Initialize ConversationManager
        conversationManager = new ConversationManager();

        // Hide modal and show chat interface
        displayNameModal.style.display = "none";
        chatContainer.style.display = "flex";

        // Connect to WebSocket
        connectWebSocket();
      }

      // Validate display name input with enhanced validation
      function validateDisplayNameInput(name) {
        displayNameError.textContent = "";

        if (!name) {
          displayNameError.textContent = "Display name cannot be empty";
          return false;
        }

        if (name.length > 50) {
          displayNameError.textContent =
            "Display name must be 50 characters or less";
          return false;
        }

        // Check for HTML tags
        if (/<[^>]*>/i.test(name)) {
          displayNameError.textContent =
            "Display name cannot contain HTML tags";
          return false;
        }

        // Check for control characters (except normal whitespace)
        for (let i = 0; i < name.length; i++) {
          const charCode = name.charCodeAt(i);
          if (
            charCode < 32 &&
            charCode !== 9 &&
            charCode !== 10 &&
            charCode !== 13
          ) {
            displayNameError.textContent =
              "Display name contains invalid characters";
            return false;
          }
        }

        // Check for script injection patterns
        if (/script|javascript|vbscript|onload|onerror|onclick/i.test(name)) {
          displayNameError.textContent =
            "Display name contains prohibited content";
          return false;
        }

        return true;
      }

      // Real-time display name validation with enhanced checks
      function validateDisplayName() {
        const name = displayNameInput.value.trim();
        const isValid = validateDisplayNameInput(name);

        joinButton.disabled = !name || !isValid;

        // Only show error if there's input to validate
        if (name && !isValid) {
          // Error message is already set by validateDisplayNameInput
        } else if (!name) {
          displayNameError.textContent = "";
        } else {
          displayNameError.textContent = "";
        }
      }

      // Handle message form submission with enhanced validation and error handling
      function handleMessageSubmit(e) {
        e.preventDefault();

        const content = messageInput.value.trim();

        // Enhanced message validation
        if (!validateMessageContent(content)) {
          return; // Error message already shown by validation function
        }

        if (!isConnected) {
          showError("Not connected to server - cannot send message");
          return;
        }

        if (!ws || ws.readyState !== WebSocket.OPEN) {
          showError("Connection not ready - please wait");
          return;
        }

        try {
          let message;
          
          // Check if we're in a private conversation
          if (conversationManager && conversationManager.activeConversation !== null) {
            // Send private message
            message = {
              type: "private",
              from: displayName,
              to: conversationManager.activeConversation,
              content: sanitizeInput(content),
              timestamp: new Date().toISOString(),
            };
          } else {
            // Send public message
            message = {
              type: "chat",
              from: displayName,
              content: sanitizeInput(content),
              timestamp: new Date().toISOString(),
            };
          }

          ws.send(JSON.stringify(message));
          messageInput.value = "";
          validateMessage();
          hideError(); // Clear any previous errors on successful send
        } catch (error) {
          console.error("Failed to send message:", error);
          showError(`Failed to send message: ${error.message}`);
        }
      }

      // Validate message content with enhanced checks
      function validateMessageContent(content) {
        if (!content) {
          showError("Cannot send empty message");
          return false;
        }

        if (content.length > 1000) {
          showError("Message too long (maximum 1000 characters)");
          return false;
        }

        // Check for script injection patterns
        if (
          /script|javascript|vbscript|onload|onerror|onclick/i.test(content)
        ) {
          showError("Message contains prohibited content");
          return false;
        }

        return true;
      }

      // Sanitize input to prevent XSS attacks
      function sanitizeInput(input) {
        // Create a temporary div element to escape HTML
        const div = document.createElement("div");
        div.textContent = input;
        return div.innerHTML;
      }

      // Real-time message validation with enhanced checks
      function validateMessage() {
        const content = messageInput.value.trim();
        const isValidLength = content.length <= 1000;
        const hasProhibitedContent =
          /script|javascript|vbscript|onload|onerror|onclick/i.test(content);

        sendButton.disabled =
          !content || !isConnected || !isValidLength || hasProhibitedContent;

        // Update UI to show validation status
        if (content && !isValidLength) {
          messageInput.style.borderColor = "#ff4444";
          messageInput.title = "Message too long (maximum 1000 characters)";
        } else if (content && hasProhibitedContent) {
          messageInput.style.borderColor = "#ff4444";
          messageInput.title = "Message contains prohibited content";
        } else {
          messageInput.style.borderColor = "";
          messageInput.title = "";
        }
      }

      // Connect to WebSocket with enhanced error handling
      function connectWebSocket() {
        // Clear any existing reconnect timeout
        if (reconnectTimeout) {
          clearTimeout(reconnectTimeout);
          reconnectTimeout = null;
        }

        connectionAttempts++;
        updateConnectionStatus(
          "connecting",
          `Connecting... (attempt ${connectionAttempts})`
        );

        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${protocol}//${window.location.host}/ws`;

        try {
          // Close existing connection if any
          if (ws && ws.readyState !== WebSocket.CLOSED) {
            ws.close();
          }

          ws = new WebSocket(wsUrl);

          // Set connection timeout
          const connectionTimeout = setTimeout(() => {
            if (ws.readyState === WebSocket.CONNECTING) {
              ws.close();
              handleConnectionTimeout();
            }
          }, 10000); // 10 second timeout

          ws.onopen = function (event) {
            clearTimeout(connectionTimeout);
            handleWebSocketOpen(event);
          };

          ws.onmessage = handleWebSocketMessage;
          ws.onclose = handleWebSocketClose;
          ws.onerror = handleWebSocketError;
        } catch (error) {
          console.error("WebSocket connection error:", error);
          showError(`Failed to connect to chat server: ${error.message}`);
          updateConnectionStatus("disconnected", "Connection failed");
          scheduleReconnect();
        }
      }

      // Handle connection timeout
      function handleConnectionTimeout() {
        console.error("WebSocket connection timeout");
        showError("Connection timeout - server may be unavailable");
        updateConnectionStatus("disconnected", "Connection timeout");
        scheduleReconnect();
      }

      // Handle WebSocket connection open
      function handleWebSocketOpen(event) {
        console.log("WebSocket connected successfully");
        isConnected = true;
        reconnectAttempts = 0;
        connectionAttempts = 0;
        lastConnectionTime = new Date();
        updateConnectionStatus("connected", "Connected");
        hideError();

        // Enable message input
        messageInput.disabled = false;
        messageInput.focus();
        validateMessage();

        // Send join message with error handling
        try {
          const joinMessage = {
            type: "join",
            from: displayName,
            content: displayName,
            timestamp: new Date().toISOString(),
          };

          ws.send(JSON.stringify(joinMessage));
          console.log("Join message sent successfully");
        } catch (error) {
          console.error("Failed to send join message:", error);
          showError("Failed to join chat - please refresh the page");
        }
      }

      // Handle incoming WebSocket messages with enhanced error handling
      function handleWebSocketMessage(event) {
        try {
          // Validate that we received data
          if (!event.data) {
            console.warn("Received empty message from server");
            return;
          }

          const message = JSON.parse(event.data);

          // Validate message structure
          if (!message.type) {
            console.warn("Received message without type field:", message);
            showError("Received malformed message from server");
            return;
          }

          switch (message.type) {
            case "chat":
              if (message.from && message.content) {
                // Route through ConversationManager
                if (conversationManager) {
                  conversationManager.addMessage(message);
                  // Only display if in active conversation (public chat)
                  if (conversationManager.activeConversation === null) {
                    displayChatMessage(message);
                  }
                } else {
                  displayChatMessage(message);
                }
              } else {
                console.warn("Invalid chat message structure:", message);
              }
              break;
            case "private":
              if (message.from && message.content) {
                // Route private messages through ConversationManager
                if (conversationManager) {
                  conversationManager.addMessage(message);
                  // Determine the conversation key for this private message
                  const conversationKey =
                    message.from === displayName ? message.to : message.from;
                  // Only display if viewing this conversation
                  if (
                    conversationManager.activeConversation === conversationKey
                  ) {
                    displayChatMessage(message);
                  } else {
                    // Update unread badge if not viewing this conversation
                    const unreadCount =
                      conversationManager.getUnreadCount(conversationKey);
                    updateUnreadBadge(conversationKey, unreadCount);
                  }
                } else {
                  displayChatMessage(message);
                }
              } else {
                console.warn("Invalid private message structure:", message);
              }
              break;
            case "system":
              if (message.content) {
                displaySystemMessage(message);
              } else {
                console.warn("Invalid system message structure:", message);
              }
              break;
            case "user_list":
              if (Array.isArray(message.users)) {
                updateUsersList(message.users);
              } else {
                console.warn("Invalid user_list message structure:", message);
              }
              break;
            case "error":
              if (message.error) {
                // Handle specific private message errors with user-friendly messages
                handlePrivateMessageError(message.error);
              } else {
                showError("Unknown server error occurred");
              }
              break;
            default:
              console.warn("Unknown message type:", message.type);
              showError(`Received unknown message type: ${message.type}`);
          }
        } catch (error) {
          console.error(
            "Error parsing message:",
            error,
            "Raw data:",
            event.data
          );
          showError(`Failed to parse server message: ${error.message}`);
        }
      }

      // Handle WebSocket connection close with enhanced reconnection logic
      function handleWebSocketClose(event) {
        console.log("WebSocket disconnected:", event.code, event.reason);
        isConnected = false;

        // Disable message input
        messageInput.disabled = true;
        sendButton.disabled = true;

        // Determine if this was an expected close or error
        const wasCleanClose = event.code === 1000 || event.code === 1001;
        const closeReason = getCloseReason(event.code);

        if (wasCleanClose) {
          updateConnectionStatus(
            "disconnected",
            `Disconnected: ${closeReason}`
          );
          showError("Connection closed by server");
        } else {
          updateConnectionStatus(
            "disconnected",
            `Connection lost: ${closeReason}`
          );
          scheduleReconnect();
        }
      }

      // Get human-readable close reason
      function getCloseReason(code) {
        switch (code) {
          case 1000:
            return "Normal closure";
          case 1001:
            return "Going away";
          case 1002:
            return "Protocol error";
          case 1003:
            return "Unsupported data";
          case 1006:
            return "Abnormal closure";
          case 1007:
            return "Invalid data";
          case 1008:
            return "Policy violation";
          case 1009:
            return "Message too big";
          case 1011:
            return "Server error";
          default:
            return `Unknown (${code})`;
        }
      }

      // Schedule reconnection with exponential backoff
      function scheduleReconnect() {
        if (reconnectAttempts >= maxReconnectAttempts) {
          showError(
            "Maximum reconnection attempts reached. Please refresh the page."
          );
          updateConnectionStatus(
            "disconnected",
            "Connection failed permanently"
          );
          return;
        }

        // Calculate delay with exponential backoff (max 30 seconds)
        const baseDelay = 1000; // 1 second
        const delay = Math.min(
          baseDelay * Math.pow(2, reconnectAttempts),
          30000
        );
        reconnectAttempts++;

        updateConnectionStatus(
          "connecting",
          `Reconnecting in ${Math.ceil(
            delay / 1000
          )}s... (${reconnectAttempts}/${maxReconnectAttempts})`
        );

        reconnectTimeout = setTimeout(() => {
          if (!isConnected) {
            connectWebSocket();
          }
        }, delay);
      }

      // Handle WebSocket errors with detailed logging
      function handleWebSocketError(error) {
        console.error("WebSocket error occurred:", error);

        // Provide user-friendly error messages based on connection state
        if (ws) {
          switch (ws.readyState) {
            case WebSocket.CONNECTING:
              showError(
                "Failed to connect to chat server - please check your internet connection"
              );
              break;
            case WebSocket.OPEN:
              showError("Connection error occurred during communication");
              break;
            case WebSocket.CLOSING:
              showError("Connection is closing due to an error");
              break;
            case WebSocket.CLOSED:
              showError("Connection closed unexpectedly");
              break;
            default:
              showError("Unknown connection error occurred");
          }
        } else {
          showError("WebSocket connection failed to initialize");
        }

        updateConnectionStatus("disconnected", "Connection error");
      }

      // Update active conversation highlighting
      function updateActiveConversation(username) {
        // Remove active class from all user items
        const allUserItems = document.querySelectorAll(".user-item");
        allUserItems.forEach((item) => item.classList.remove("active"));

        // Add active class to the selected conversation
        if (username === null) {
          // Public chat
          const publicChatButton = document.getElementById("publicChatButton");
          if (publicChatButton) {
            publicChatButton.classList.add("active");
          }
        } else {
          // Private conversation - find the user item
          const userItems = document.querySelectorAll(
            ".user-item:not(.public-chat)"
          );
          userItems.forEach((item) => {
            if (item.dataset.username === username) {
              item.classList.add("active");
            }
          });
        }
      }

      // Load conversation history when switching conversations
      function loadConversationHistory(username) {
        if (!conversationManager) return;

        // Clear current messages
        messagesContainer.innerHTML = "";

        // Get messages for this conversation
        const messages = conversationManager.getMessages(username);

        // Display all messages
        messages.forEach((message) => {
          const messageType =
            message.type === "system" ? "system" : "chat";
          const messageElement = createMessageElement(message, messageType);
          messagesContainer.appendChild(messageElement);
        });

        // Restore scroll position or scroll to bottom
        const savedScrollPosition = conversationManager.getScrollPosition(username);
        if (savedScrollPosition !== null) {
          // Restore saved scroll position
          messagesContainer.scrollTop = savedScrollPosition;
        } else {
          // Scroll to bottom for new conversations
          scrollToBottom();
        }
      }

      // Display chat message
      function displayChatMessage(message) {
        const messageElement = createMessageElement(message, "chat");
        messagesContainer.appendChild(messageElement);
        scrollToBottom();
      }

      // Display system message
      function displaySystemMessage(message) {
        const messageElement = createMessageElement(message, "system");
        messagesContainer.appendChild(messageElement);
        scrollToBottom();
      }

      // Create message element
      function createMessageElement(message, type) {
        const messageDiv = document.createElement("div");
        
        // Add private class if this is a private message
        const isPrivate = message.type === "private";
        messageDiv.className = `message ${type}${isPrivate ? ' private' : ''}`;

        const timestamp = new Date(message.timestamp).toLocaleTimeString();

        if (type === "system") {
          messageDiv.innerHTML = `
                    <div class="message-header">
                        <span class="message-from">System</span>
                        <span class="message-timestamp">${timestamp}</span>
                    </div>
                    <div class="message-content">${escapeHtml(
                      message.content
                    )}</div>
                `;
        } else {
          // Add private message indicator if applicable
          const privateIndicator = isPrivate ? '<span class="private-indicator">üîí Private</span>' : '';
          
          messageDiv.innerHTML = `
                    <div class="message-header">
                        <span class="message-from">${escapeHtml(
                          message.from
                        )}</span>${privateIndicator}
                        <span class="message-timestamp">${timestamp}</span>
                    </div>
                    <div class="message-content">${escapeHtml(
                      message.content
                    )}</div>
                `;
        }

        return messageDiv;
      }

      // Track previous user list to detect disconnections
      let previousUserList = [];

      // Update users list
      function updateUsersList(users) {
        // Detect disconnected users
        const disconnectedUsers = previousUserList.filter(
          (user) => !users.includes(user)
        );

        // Handle disconnections
        disconnectedUsers.forEach((user) => {
          handleUserDisconnect(user);
        });

        // Update previous user list
        previousUserList = [...users];

        // Store the public chat button HTML before clearing
        const publicChatButton = document.getElementById("publicChatButton");
        const publicChatHTML = publicChatButton
          ? publicChatButton.outerHTML
          : '<div class="user-item public-chat active" id="publicChatButton"><span class="user-name">üì¢ Public Chatroom</span></div>';

        usersList.innerHTML = publicChatHTML;
        usersCount.textContent = `${users.length} user${
          users.length !== 1 ? "s" : ""
        } online`;

        users.forEach((user) => {
          const userElement = document.createElement("div");
          userElement.className = "user-item";
          userElement.dataset.username = user;

          // Check if this is the current user
          const isCurrentUser = user === displayName;
          if (isCurrentUser) {
            userElement.classList.add("current-user");
          }

          // Create user name span
          const userNameSpan = document.createElement("span");
          userNameSpan.className = "user-name";
          userNameSpan.textContent = user;
          userElement.appendChild(userNameSpan);

          // Create unread badge
          const unreadBadge = document.createElement("span");
          unreadBadge.className = "unread-badge";
          unreadBadge.style.display = "none";
          unreadBadge.textContent = "0";
          userElement.appendChild(unreadBadge);

          // Create online indicator
          const onlineIndicator = document.createElement("span");
          onlineIndicator.className = "online-indicator";
          userElement.appendChild(onlineIndicator);

          // Add click event listener
          userElement.addEventListener("click", function () {
            handleUserClick(user);
          });

          usersList.appendChild(userElement);
        });

        // Re-attach public chat button click handler
        const newPublicChatButton = document.getElementById("publicChatButton");
        if (newPublicChatButton) {
          newPublicChatButton.addEventListener("click", function () {
            handlePublicChatClick();
          });
        }

        // Update UI if viewing conversation with reconnected user
        if (conversationManager && conversationManager.activeConversation !== null) {
          const activeUser = conversationManager.activeConversation;
          if (users.includes(activeUser)) {
            // User is online - ensure message input is enabled
            handleUserReconnect(activeUser);
          }
        }
      }

      // Handle user disconnect
      function handleUserDisconnect(username) {
        if (!conversationManager) return;

        // Check if we're viewing a conversation with the disconnected user
        if (conversationManager.activeConversation === username) {
          // Display system message about user going offline
          const systemMessage = {
            type: "system",
            content: `${username} has gone offline`,
            timestamp: new Date().toISOString(),
          };
          displaySystemMessage(systemMessage);

          // Disable message input
          messageInput.disabled = true;
          sendButton.disabled = true;
          messageInput.placeholder = `${username} is offline`;

          // Add visual indicator in chat header
          updateChatHeaderOffline(username);

          // Automatically switch to public chat
          setTimeout(() => {
            switchToPublicAfterDisconnect(username);
          }, 2000); // Wait 2 seconds before auto-switching
        }

        // Clear conversation history for disconnected user
        conversationManager.clearConversation(username);

        // Remove unread badges for disconnected user
        updateUnreadBadge(username, 0);
      }

      // Handle user reconnect
      function handleUserReconnect(username) {
        if (!conversationManager) return;

        // Check if we're viewing a conversation with the reconnected user
        if (conversationManager.activeConversation === username) {
          // Re-enable message input if connected
          if (isConnected) {
            messageInput.disabled = false;
            validateMessage();
            messageInput.placeholder = `Message ${username}...`;
          }

          // Update chat header to remove offline indicator
          updateChatHeader(username);

          // Display system message about user reconnecting
          const systemMessage = {
            type: "system",
            content: `${username} is back online`,
            timestamp: new Date().toISOString(),
          };
          displaySystemMessage(systemMessage);
        }
      }

      // Switch to public chat after user disconnect
      function switchToPublicAfterDisconnect(username) {
        if (!conversationManager) return;

        // Only switch if still viewing the disconnected user's conversation
        if (conversationManager.activeConversation === username) {
          // Show notification about automatic switch
          const systemMessage = {
            type: "system",
            content: `Switched to public chatroom because ${username} disconnected`,
            timestamp: new Date().toISOString(),
          };

          // Switch to public conversation
          conversationManager.switchConversation(null);

          // Update UI to show public conversation
          updateActiveConversation(null);

          // Update chat header to show public chatroom
          updateChatHeader(null);

          // Update message input placeholder
          updateMessagePlaceholder(null);

          // Load public conversation history
          loadConversationHistory(null);

          // Display the notification in public chat
          displaySystemMessage(systemMessage);

          // Re-enable message input if connected
          if (isConnected) {
            messageInput.disabled = false;
            validateMessage();
          }
        }
      }

      // Update chat header to show offline status
      function updateChatHeaderOffline(username) {
        if (activeConversationName) {
          activeConversationName.innerHTML = `Private chat with ${escapeHtml(username)} <span style="color: #ff4444; font-size: 14px;">‚óè Offline</span>`;
        }
      }

      // Handle user click for private messaging
      function handleUserClick(username) {
        if (!conversationManager) return;

        // Prevent clicking on current user's own name
        if (username === displayName) {
          showError("You cannot send messages to yourself");
          return;
        }

        // Switch to private conversation
        conversationManager.switchConversation(username);

        // Update UI to show private conversation
        updateActiveConversation(username);

        // Update chat header to show private conversation
        updateChatHeader(username);

        // Update message input placeholder
        updateMessagePlaceholder(username);

        // Clear unread badge for this user
        updateUnreadBadge(username, 0);

        // Load private conversation history
        loadConversationHistory(username);
      }

      // Handle private message errors with user-friendly messages
      function handlePrivateMessageError(errorMessage) {
        // Normalize error message to lowercase for easier matching
        const errorLower = errorMessage.toLowerCase();

        // Handle "recipient not found" errors
        if (errorLower.includes("recipient not found") || 
            errorLower.includes("recipient") && errorLower.includes("offline")) {
          // Extract recipient name if possible
          const recipientMatch = errorMessage.match(/to\s+(\w+)/i);
          const recipient = recipientMatch ? recipientMatch[1] : "recipient";
          
          showError(`Unable to send message: ${recipient} is not online or has disconnected`);
          
          // If viewing conversation with offline user, show additional context
          if (conversationManager && conversationManager.activeConversation) {
            const activeUser = conversationManager.activeConversation;
            if (errorLower.includes(activeUser.toLowerCase())) {
              // Display system message in chat
              const systemMessage = {
                type: "system",
                content: `${activeUser} is offline and cannot receive messages`,
                timestamp: new Date().toISOString(),
              };
              displaySystemMessage(systemMessage);
            }
          }
          return;
        }

        // Handle "user offline" errors
        if (errorLower.includes("user") && errorLower.includes("offline")) {
          showError("Cannot send message: User is offline");
          return;
        }

        // Handle "cannot message yourself" errors
        if (errorLower.includes("yourself") || 
            errorLower.includes("cannot send") && errorLower.includes("to yourself")) {
          showError("You cannot send private messages to yourself");
          return;
        }

        // Handle rate limit errors
        if (errorLower.includes("rate limit")) {
          showError("You're sending messages too quickly. Please slow down.");
          return;
        }

        // Handle validation errors
        if (errorLower.includes("validation")) {
          showError("Message validation failed. Please check your message and try again.");
          return;
        }

        // Handle server busy errors
        if (errorLower.includes("server busy") || errorLower.includes("channel full")) {
          showError("Server is busy. Please try again in a moment.");
          return;
        }

        // Handle authentication errors
        if (errorLower.includes("must join") || errorLower.includes("authentication")) {
          showError("You must join the chat before sending messages");
          return;
        }

        // Default error handling for unrecognized errors
        showError(`Server error: ${errorMessage}`);
      }

      // Update unread badge for a user
      function updateUnreadBadge(username, count) {
        if (!username) return; // No badge for public chat

        const userItems = document.querySelectorAll(
          ".user-item:not(.public-chat)"
        );
        userItems.forEach((item) => {
          if (item.dataset.username === username) {
            const badge = item.querySelector(".unread-badge");
            if (badge) {
              if (count > 0) {
                badge.textContent = count;
                badge.style.display = "inline-block";
              } else {
                badge.style.display = "none";
              }
            }
          }
        });
      }

      // Update chat header to show active conversation name
      function updateChatHeader(username) {
        if (activeConversationName) {
          if (username === null) {
            activeConversationName.textContent = "Public Chatroom";
          } else {
            activeConversationName.textContent = `Private chat with ${username}`;
          }
        }
      }

      // Update message input placeholder text
      function updateMessagePlaceholder(username) {
        if (messageInput) {
          if (username === null) {
            messageInput.placeholder = "Type your message...";
          } else {
            messageInput.placeholder = `Message ${username}...`;
          }
        }
      }

      // Update all unread badges from ConversationManager
      function updateAllUnreadBadges() {
        if (!conversationManager) return;

        const userItems = document.querySelectorAll(
          ".user-item:not(.public-chat)"
        );
        userItems.forEach((item) => {
          const username = item.dataset.username;
          if (username) {
            const count = conversationManager.getUnreadCount(username);
            const badge = item.querySelector(".unread-badge");
            if (badge) {
              if (count > 0) {
                badge.textContent = count;
                badge.style.display = "inline-block";
              } else {
                badge.style.display = "none";
              }
            }
          }
        });
      }

      // Update connection status with enhanced information
      function updateConnectionStatus(status, text) {
        statusIndicator.className = `status-indicator ${status}`;

        // Add additional connection info for debugging
        let statusInfo = text;
        if (status === "connected" && lastConnectionTime) {
          const uptime = Math.floor((new Date() - lastConnectionTime) / 1000);
          statusInfo += ` (${uptime}s)`;
        }

        statusText.textContent = statusInfo;

        // Update page title to reflect connection status
        const baseTitle = "Realtime Chatroom";
        switch (status) {
          case "connected":
            document.title = baseTitle;
            break;
          case "connecting":
            document.title = `${baseTitle} - Connecting...`;
            break;
          case "disconnected":
            document.title = `${baseTitle} - Disconnected`;
            break;
        }
      }

      // Periodic connection health check
      function startConnectionHealthCheck() {
        setInterval(() => {
          if (isConnected && ws && ws.readyState === WebSocket.OPEN) {
            // Update uptime display
            if (lastConnectionTime) {
              const uptime = Math.floor(
                (new Date() - lastConnectionTime) / 1000
              );
              updateConnectionStatus("connected", `Connected (${uptime}s)`);
            }
          }
        }, 5000); // Update every 5 seconds
      }

      // Show error message with timestamp and auto-hide
      function showError(message) {
        const timestamp = new Date().toLocaleTimeString();
        errorDisplay.innerHTML = `<strong>Error (${timestamp}):</strong> ${escapeHtml(
          message
        )}`;
        errorDisplay.style.display = "block";

        // Auto-hide error after 10 seconds for non-critical errors
        if (!message.includes("refresh") && !message.includes("permanently")) {
          setTimeout(() => {
            if (errorDisplay.textContent.includes(message)) {
              hideError();
            }
          }, 10000);
        }
      }

      // Hide error message
      function hideError() {
        errorDisplay.style.display = "none";
        errorDisplay.innerHTML = "";
      }

      // Auto-scroll to bottom of messages
      function scrollToBottom() {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      // Escape HTML to prevent XSS
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }
    </script>
  </body>
</html>
